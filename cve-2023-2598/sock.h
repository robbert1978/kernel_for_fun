#ifndef SOCK_H
#define SOCK_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

// Placeholder types for kernel-specific structures
typedef struct proto proto_t;
typedef struct dst_entry dst_entry_t;
typedef struct sk_buff sk_buff_t;
typedef struct sk_filter sk_filter_t;
typedef struct socket_wq socket_wq_t;
typedef struct xfrm_policy xfrm_policy_t;
typedef struct sock_reuseport sock_reuseport_t;
typedef struct bpf_local_storage bpf_local_storage_t;
typedef struct net_device net_device_t;
typedef int pid_t;
typedef struct cred cred_t;
typedef struct mem_cgroup mem_cgroup_t;
typedef struct cgroup cgroup_t;

// User-space equivalents for kernel types
typedef uint32_t __be32;
typedef uint16_t __be16;
typedef uint32_t __u32;
typedef uint16_t __u16;
typedef uint8_t __u8;
typedef int64_t atomic64_t;
typedef int32_t atomic_t;
typedef int32_t __s32;
typedef uint32_t refcount_t;
typedef uint64_t netdev_features_t;
typedef uint32_t gfp_t;
typedef uint32_t kuid_t;
typedef int64_t ktime_t;

// Placeholder for possible_net_t and netns_tracker
typedef void *possible_net_t;
typedef void *netns_tracker;

// Simple linked list node (hlist_node equivalent)
struct hlist_node {
  struct hlist_node *next;   // 8 bytes
  struct hlist_node **pprev; // 8 bytes
};

// Simplified socket lock (spinlock placeholder)
typedef uint32_t spinlock_t;

// Address pair union
typedef struct {
  __be32 skc_daddr;     // 4 bytes
  __be32 skc_rcv_saddr; // 4 bytes
} addrpair_t;

// Port pair union
typedef struct {
  __be16 skc_dport; // 2 bytes
  __u16 skc_num;    // 2 bytes
} portpair_t;

// IPv6 address structure
struct k_in6_addr {
  union {
    __u8 u6_addr8[16];   // 16 bytes
    __be16 u6_addr16[8]; // 16 bytes
    __be32 u6_addr32[4]; // 16 bytes
  } in6_u;
};

// Simplified sk_buff_head
struct sk_buff_head {
  union {
    struct {
      sk_buff_t *next; // 8 bytes
      sk_buff_t *prev; // 8 bytes
    };
    struct {
      sk_buff_t *next; // 8 bytes
      sk_buff_t *prev; // 8 bytes
    } list;
  };
  __u32 qlen;      // 4 bytes
  spinlock_t lock; // 4 bytes
};

// Simplified page_frag
struct page_frag {
  void *page;   // 8 bytes
  __u32 offset; // 4 bytes
  __u32 size;   // 4 bytes
};

// Simplified timer_list
struct timer_list {
  struct hlist_node entry;               // 16 bytes
  unsigned long expires;                 // 8 bytes
  void (*function)(struct timer_list *); // 8 bytes
  __u32 flags;                           // 4 bytes
  uint8_t padding[4];                    // 4 bytes padding to match 40 bytes
};

// Simplified callback_head
struct callback_head {
  struct callback_head *next;           // 8 bytes
  void (*func)(struct callback_head *); // 8 bytes
};

// Simplified sock_cgroup_data
struct sock_cgroup_data {
  cgroup_t *cgroup;   // 8 bytes
  __u32 classid;      // 4 bytes
  __u16 prioidx;      // 2 bytes
  uint8_t padding[2]; // 2 bytes padding to match 16 bytes
};

// Main sock structure
struct sock {
  struct sock_common {
    union {
      addrpair_t skc_addrpair; // 8 bytes
      struct {
        __be32 skc_daddr;     // 4 bytes (offset 0)
        __be32 skc_rcv_saddr; // 4 bytes (offset 4)
      };
    };
    union {
      unsigned int skc_hash; // 4 bytes (offset 8)
      __u16 skc_u16hashes[2];
    };
    union {
      portpair_t skc_portpair; // 4 bytes
      struct {
        __be16 skc_dport; // 2 bytes (offset 12)
        __u16 skc_num;    // 2 bytes (offset 14)
      };
    };
    unsigned short skc_family;   // 2 bytes (offset 16)
    unsigned char skc_state;     // 1 byte  (offset 18)
    unsigned char skc_reuse : 4, // 1 byte  (offset 19)
        skc_reuseport : 1, skc_ipv6only : 1, skc_net_refcnt : 1;
    uint8_t padding1 : 1; // 1-bit hole
    int skc_bound_dev_if; // 4 bytes (offset 20)
    union {
      struct hlist_node skc_bind_node;     // 16 bytes (offset 24)
      struct hlist_node skc_portaddr_node; // 16 bytes
    };
    proto_t *skc_prot;                  // 8 bytes (offset 40)
    possible_net_t skc_net;             // 8 bytes (offset 48)
    struct k_in6_addr skc_v6_daddr;     // 16 bytes (offset 56)
    struct k_in6_addr skc_v6_rcv_saddr; // 16 bytes (offset 72)
    atomic64_t skc_cookie;              // 8 bytes (offset 88)
    union {
      unsigned long skc_flags; // 8 bytes (offset 96)
      struct sock *skc_listener;
      void *skc_tw_dr;
    };
    int skc_dontcopy_begin[0]; // 0 bytes (offset 104)
    union {
      struct hlist_node skc_node; // 16 bytes (offset 104)
      struct hlist_node skc_nulls_node;
    };
    unsigned short skc_tx_queue_mapping; // 2 bytes (offset 120)
    unsigned short skc_rx_queue_mapping; // 2 bytes (offset 122)
    union {
      int skc_incoming_cpu; // 4 bytes (offset 124)
      __u32 skc_rcv_wnd;
      __u32 skc_tw_rcv_nxt;
    };
    refcount_t skc_refcnt;   // 4 bytes (offset 128)
    int skc_dontcopy_end[0]; // 0 bytes (offset 132)
    union {
      __u32 skc_rxhash; // 4 bytes (offset 132)
      __u32 skc_window_clamp;
      __u32 skc_tw_snd_nxt;
    };
  } __sk_common; // Total 136 bytes (ends at offset 136)

  dst_entry_t *sk_rx_dst; // 8 bytes (offset 136)
  int sk_rx_dst_ifindex;  // 4 bytes (offset 144)
  __u32 sk_rx_dst_cookie; // 4 bytes (offset 148)
  uint32_t sk_lock; // 4 bytes (offset 152), simplified socket_lock_t (32 bytes
                    // originally)
  uint8_t padding2[28]; // 28 bytes padding to match 32 bytes (ends at 184)
  atomic_t sk_drops;    // 4 bytes (offset 184)
  int sk_rcvlowat;      // 4 bytes (offset 188)
  struct sk_buff_head sk_error_queue;   // 24 bytes (offset 192)
  struct sk_buff_head sk_receive_queue; // 24 bytes (offset 216)
  struct {
    atomic_t rmem_alloc;   // 4 bytes (offset 240)
    int len;               // 4 bytes (offset 244)
    sk_buff_t *head;       // 8 bytes (offset 248)
    sk_buff_t *tail;       // 8 bytes (offset 256)
  } sk_backlog;            // 24 bytes (ends at 264)
  int sk_forward_alloc;    // 4 bytes (offset 264)
  __u32 sk_reserved_mem;   // 4 bytes (offset 268)
  unsigned int sk_ll_usec; // 4 bytes (offset 272)
  unsigned int sk_napi_id; // 4 bytes (offset 276)
  int sk_rcvbuf;           // 4 bytes (offset 280)
  uint8_t padding3[4];     // 4-byte hole (offset 284-287)
  sk_filter_t *sk_filter;  // 8 bytes (offset 288)
  union {
    socket_wq_t *sk_wq; // 8 bytes (offset 296)
    socket_wq_t *sk_wq_raw;
  };
  xfrm_policy_t *sk_policy[2]; // 16 bytes (offset 304)
  dst_entry_t *sk_dst_cache;   // 8 bytes (offset 320)
  atomic_t sk_omem_alloc;      // 4 bytes (offset 328)
  int sk_sndbuf;               // 4 bytes (offset 332)
  int sk_wmem_queued;          // 4 bytes (offset 336)
  refcount_t sk_wmem_alloc;    // 4 bytes (offset 340)
  unsigned long sk_tsq_flags;  // 8 bytes (offset 344)
  union {
    sk_buff_t *sk_send_head; // 8 bytes (offset 352)
    struct {
      void *rb_node;
    } tcp_rtx_queue;
  };
  struct sk_buff_head sk_write_queue; // 24 bytes (offset 360)
  __s32 sk_peek_off;                  // 4 bytes (offset 384)
  int sk_write_pending;               // 4 bytes (offset 388)
  __u32 sk_dst_pending_confirm;       // 4 bytes (offset 392)
  __u32 sk_pacing_status;             // 4 bytes (offset 396)
  long sk_sndtimeo;                   // 8 bytes (offset 400)
  struct timer_list sk_timer;         // 40 bytes (offset 408)
  __u32 sk_priority;                  // 4 bytes (offset 448)
  __u32 sk_mark;                      // 4 bytes (offset 452)
  unsigned long sk_pacing_rate;       // 8 bytes (offset 456)
  unsigned long sk_max_pacing_rate;   // 8 bytes (offset 464)
  struct page_frag sk_frag;           // 16 bytes (offset 472)
  netdev_features_t sk_route_caps;    // 8 bytes (offset 488)
  int sk_gso_type;                    // 4 bytes (offset 496)
  unsigned int sk_gso_max_size;       // 4 bytes (offset 500)
  gfp_t sk_allocation;                // 4 bytes (offset 504)
  __u32 sk_txhash;                    // 4 bytes (offset 508)
  uint8_t sk_gso_disabled : 1,        // 1 byte (offset 512)
      sk_kern_sock : 1, sk_no_check_tx : 1, sk_no_check_rx : 1,
      sk_userlocks : 4;
  uint8_t sk_pacing_shift;     // 1 byte (offset 513)
  __u16 sk_type;               // 2 bytes (offset 514)
  __u16 sk_protocol;           // 2 bytes (offset 516)
  __u16 sk_gso_max_segs;       // 2 bytes (offset 518)
  unsigned long sk_lingertime; // 8 bytes (offset 520)
  proto_t *sk_prot_creator;    // 8 bytes (offset 528)
  uint32_t sk_callback_lock;   // 4 bytes (offset 536), simplified rwlock_t
  uint8_t padding4[4];         // 4 bytes padding to align (ends at 544)
  int sk_err;                  // 4 bytes (offset 544)
  int sk_err_soft;             // 4 bytes (offset 548)
  __u32 sk_ack_backlog;        // 4 bytes (offset 552)
  __u32 sk_max_ack_backlog;    // 4 bytes (offset 556)
  kuid_t sk_uid;               // 4 bytes (offset 560)
  uint8_t sk_txrehash;         // 1 byte (offset 564)
  uint8_t sk_prefer_busy_poll; // 1 byte (offset 565)
  __u16 sk_busy_poll_budget;   // 2 bytes (offset 566)
  spinlock_t sk_peer_lock;     // 4 bytes (offset 568)
  int sk_bind_phc;             // 4 bytes (offset 572)
  pid_t *sk_peer_pid;          // 8 bytes (offset 576)
  const cred_t *sk_peer_cred;  // 8 bytes (offset 584)
  long sk_rcvtimeo;            // 8 bytes (offset 592)
  ktime_t sk_stamp;            // 8 bytes (offset 600)
  atomic_t sk_tskey;           // 4 bytes (offset 608)
  atomic_t sk_zckey;           // 4 bytes (offset 612)
  __u32 sk_tsflags;            // 4 bytes (offset 616)
  uint8_t sk_shutdown;         // 1 byte (offset 620)
  uint8_t sk_clockid;          // 1 byte (offset 621)
  uint8_t sk_txtime_deadline_mode : 1, // 1 byte (offset 622)
      sk_txtime_report_errors : 1, sk_txtime_unused : 6;
  bool sk_use_task_frag;                             // 1 byte (offset 623)
  void *sk_socket;                                   // 8 bytes (offset 624)
  void *sk_user_data;                                // 8 bytes (offset 632)
  void *sk_security;                                 // 8 bytes (offset 640)
  struct sock_cgroup_data sk_cgrp_data;              // 16 bytes (offset 648)
  mem_cgroup_t *sk_memcg;                            // 8 bytes (offset 664)
  void (*sk_state_change)(struct sock *);            // 8 bytes (offset 672)
  void (*sk_data_ready)(struct sock *);              // 8 bytes (offset 680)
  void (*sk_write_space)(struct sock *);             // 8 bytes (offset 688)
  void (*sk_error_report)(struct sock *);            // 8 bytes (offset 696)
  int (*sk_backlog_rcv)(struct sock *, sk_buff_t *); // 8 bytes (offset 704)
  sk_buff_t *(*sk_validate_xmit_skb)(struct sock *, net_device_t *,
                                     sk_buff_t *); // 8 bytes (offset 712)
  void (*sk_destruct)(struct sock *);              // 8 bytes (offset 720)
  sock_reuseport_t *sk_reuseport_cb;               // 8 bytes (offset 728)
  bpf_local_storage_t *sk_bpf_storage;             // 8 bytes (offset 736)
  struct callback_head sk_rcu;                     // 16 bytes (offset 744)
  netns_tracker ns_tracker;        // 0 bytes (offset 760), placeholder
  struct hlist_node sk_bind2_node; // 16 bytes (offset 760)
}; // Total 776 bytes (ends at offset 776)

struct proto {
  /*      0      |       8 */ void (*close)(struct sock *, long);
  /*      8      |       8 */ int (*pre_connect)(struct sock *,
                                                 struct sockaddr *, int);
  /*     16      |       8 */ int (*connect)(struct sock *, struct sockaddr *,
                                             int);
  /*     24      |       8 */ int (*disconnect)(struct sock *, int);
  /*     32      |       8 */ struct sock *(*accept)(struct sock *, int, int *,
                                                     bool);
  /*     40      |       8 */ int (*ioctl)(struct sock *, int, unsigned long);
  /*     48      |       8 */ int (*init)(struct sock *);
  /*     56      |       8 */ void (*destroy)(struct sock *);
  /*     64      |       8 */ void (*shutdown)(struct sock *, int);
  /*     72      |       8 */ int (*setsockopt)(struct sock *, int, int, void *,
                                                unsigned int);
  /*     80      |       8 */ int (*getsockopt)(struct sock *, int, int, char *,
                                                int *);
  /*     88      |       8 */ void (*keepalive)(struct sock *, int);
  /*     96      |       8 */ int (*compat_ioctl)(struct sock *, unsigned int,
                                                  unsigned long);
  /*    104      |       8 */ int (*sendmsg)(struct sock *, struct msghdr *,
                                             size_t);
  /*    112      |       8 */ int (*recvmsg)(struct sock *, struct msghdr *,
                                             size_t, int, int *);
  /*    120      |       8 */ int (*sendpage)(struct sock *, struct page *, int,
                                              size_t, int);
  /*    128      |       8 */ int (*bind)(struct sock *, struct sockaddr *,
                                          int);
  /*    136      |       8 */ int (*bind_add)(struct sock *, struct sockaddr *,
                                              int);
  /*    144      |       8 */ int (*backlog_rcv)(struct sock *,
                                                 struct sk_buff *);
  /*    152      |       8 */ bool (*bpf_bypass_getsockopt)(int, int);
  /*    160      |       8 */ void (*release_cb)(struct sock *);
  /*    168      |       8 */ int (*hash)(struct sock *);
  /*    176      |       8 */ void (*unhash)(struct sock *);
  /*    184      |       8 */ void (*rehash)(struct sock *);
  /*    192      |       8 */ int (*get_port)(struct sock *, unsigned short);
  /*    200      |       8 */ void (*put_port)(struct sock *);
  /*    208      |       8 */ int (*psock_update_sk_prot)(struct sock *,
                                                          struct sk_psock *,
                                                          bool);
  /*    216      |       4 */ unsigned int inuse_idx;
  /* XXX  4-byte hole      */
  /*    224      |       8 */ bool (*stream_memory_free)(const struct sock *,
                                                         int);
  /*    232      |       8 */ bool (*sock_is_readable)(struct sock *);
  /*    240      |       8 */ void (*enter_memory_pressure)(struct sock *);
  /*    248      |       8 */ void (*leave_memory_pressure)(struct sock *);
  /*    256      |       8 */ uint32_t *memory_allocated;
  /*    264      |       8 */ int *per_cpu_fw_alloc;
  /*    272      |       8 */ struct percpu_counter *sockets_allocated;
  /*    280      |       8 */ unsigned long *memory_pressure;
  /*    288      |       8 */ long *sysctl_mem;
  /*    296      |       8 */ int *sysctl_wmem;
  /*    304      |       8 */ int *sysctl_rmem;
  /*    312      |       4 */ uint32_t sysctl_wmem_offset;
  /*    316      |       4 */ uint32_t sysctl_rmem_offset;
  /*    320      |       4 */ int max_header;
  /*    324      |       1 */ bool no_autobind;
  /* XXX  3-byte hole      */
  /*    328      |       8 */ struct kmem_cache *slab;
  /*    336      |       4 */ unsigned int obj_size;
  /*    340      |       4 */ uint32_t slab_flags;
  /*    344      |       4 */ unsigned int useroffset;
  /*    348      |       4 */ unsigned int usersize;
  /*    352      |       8 */ unsigned int *orphan_count;
  /*    360      |       8 */ struct request_sock_ops *rsk_prot;
  /*    368      |       8 */ struct timewait_sock_ops *twsk_prot;
  /*    376      |       8 */ union {
    /*                     8 */ struct inet_hashinfo *hashinfo;
    /*                     8 */ struct udp_table *udp_table;
    /*                     8 */ struct raw_hashinfo *raw_hash;
    /*                     8 */ struct smc_hashinfo *smc_hash;

    /* total size (bytes):    8 */
  } h;
  /*    384      |       8 */ struct module *owner;
  /*    392      |      32 */ char name[32];
  /*    424      |      16 */ struct list_head {
    /*    424      |       8 */ struct list_head *next;
    /*    432      |       8 */ struct list_head *prev;

    /* total size (bytes):   16 */
  } node;
  /*    440      |       8 */ int (*diag_destroy)(struct sock *, int);

  /* total size (bytes):  448 */
};

#endif // SOCK_H